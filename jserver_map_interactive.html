

locations = [
    {"name": "鍾乳洞村", "x": -847, "y": 61, "z": -322},
    {"name": "仮エントランス", "x": 20, "y": 66, "z": -70},
    {"name": "ダークファンタジーエリア", "x": 2003, "y": 72, "z": 2176},
    {"name": "ticking area", "x": 1000, "y": 63, "z": 1000},
    {"name": "しめくらげ'sモダンタウン", "x": -4974, "y": 63, "z": -4991},
    {"name": "カオス2区", "x": 236, "y": 68, "z": -128},
    {"name": "西洋区", "x": -1228, "y": 71, "z": 500},
    {"name": "現代区", "x": -229, "y": 69, "z": -3039},
    {"name": "ヨコノロエリア", "x": -1210, "y": 72, "z": -880},
    {"name": "じぇりあ", "x": 400, "y": 105, "z": 400},
    {"name": "サーカス遊園地", "x": -4674, "y": 63, "z": -5609},
    {"name": "スタジアム", "x": -61, "y": 71, "z": 65},
    {"name": "群玉閣", "x": -112, "y": 182, "z": 380},
    {"name": "神社", "x": 156, "y": 64, "z": 357},
    {"name": "戦艦", "x": 433, "y": 92, "z": 783},
    {"name": "Pochi's House", "x": 1019, "y": 74, "z": 751},
    {"name": "なつめ's ウーパーハウス", "x": 1033, "y": 69, "z": 425},
    {"name": "都市公園", "x": -212, "y": 64, "z": 32},
    {"name": "鳥居", "x": 1680, "y": 80, "z": -1213},
]

min_x = min(p["x"] for p in locations)
max_x = max(p["x"] for p in locations)
min_z = min(p["z"] for p in locations)
max_z = max(p["z"] for p in locations)
margin = 500

vb_x = min_x - margin
vb_y = min_z - margin
vb_w = (max_x - min_x) + 2 * margin
vb_h = (max_z - min_z) + 2 * margin

grid = 500
grid_xs = list(range((min_x // grid - 1) * grid, (max_x // grid + 2) * grid, grid))
grid_zs = list(range((min_z // grid - 1) * grid, (max_z // grid + 2) * grid, grid))

def esc(s: str) -> str:
    return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', "&quot;")

points_svg = []
labels_svg = []
for p in locations:
    points_svg.append(
        f'<circle class="poi" cx="{p["x"]}" cy="{p["z"]}" r="40" '
        f'stroke-width="4" '
        f'data-name="{esc(p["name"])}" data-x="{p["x"]}" data-y="{p["y"]}" data-z="{p["z"]}">'
        f'<title>{esc(p["name"])}&#10;{p["x"]} {p["y"]} {p["z"]}</title>'
        f'</circle>'
    )
    labels_svg.append(f'<text class="label" x="{p["x"] + 80}" y="{p["z"]}" font-size="80">{esc(p["name"])}</text>')

grid_svg = []
for gx in grid_xs:
    grid_svg.append(f'<line class="grid" x1="{gx}" y1="{vb_y}" x2="{gx}" y2="{vb_y + vb_h}"></line>')
for gz in grid_zs:
    grid_svg.append(f'<line class="grid" x1="{vb_x}" y1="{gz}" x2="{vb_x + vb_w}" y2="{gz}"></line>')

axes_svg = [
    f'<line class="axis" x1="0" y1="{vb_y}" x2="0" y2="{vb_y + vb_h}"></line>',
    f'<line class="axis" x1="{vb_x}" y1="0" x2="{vb_x + vb_w}" y2="0"></line>',
]

html = f"""<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Interactive J-Server 2025 Map (X-East, Z-North)</title>
<style>
  html, body {{
    height: 100%;
    margin: 0;
    background: #0f1115;
    color: #eaeaea;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Hiragino Kaku Gothic ProN', 'Yu Gothic', 'Noto Sans CJK JP', 'Noto Sans JP', sans-serif;
  }}
  #container {{
    height: 100%;
    display: grid;
    grid-template-rows: auto auto auto 1fr;
  }}
  #toolbar, #toolbar2, #toolbarZoom {{
    display: flex; flex-wrap: wrap; gap: 12px; align-items: center;
    padding: 10px 12px; background: #161a22; border-bottom: 1px solid #2a3140;
  }}
  #toolbar2 {{ position: sticky; top: 48px; z-index: 3; }}
  #toolbarZoom {{ position: sticky; top: 96px; z-index: 3; }}
  #toolbar select, #toolbar button, #toolbar input[type="checkbox"],
  #toolbar2 input[type="range"], #toolbar2 label, #toolbar2 input[type="checkbox"],
  #toolbarZoom input[type="range"], #toolbarZoom label {{
    background: #0f1115; color: #eaeaea; border: 1px solid #2a3140;
    padding: 6px 8px; border-radius: 8px;
  }}
  #toolbar button {{ cursor: pointer; }}
  #mapwrap {{ position: relative; overflow: hidden; }}
  svg {{ width: 100%; height: 100%; display: block; background: #0b0d11;
        cursor: grab; user-select: none; }}
  svg:active {{ cursor: grabbing; }}
  .grid {{ stroke: #2a3140; stroke-width: 1; }}
  .axis {{ stroke: #98a2b3; stroke-width: 2; }}
  .poi {{ fill: #eaeaea; fill-opacity: 0.9; stroke: #0b0d11; }}
  .label {{ fill: #eaeaea; paint-order: stroke; stroke: #0b0d11; stroke-width: 16px; dominant-baseline: middle; }}
  .hud {{ position: absolute; right: 14px; top: 14px; background: rgba(22,26,34,0.8);
          border: 1px solid #2a3140; padding: 8px 10px; border-radius: 10px; font-size: 12px; line-height: 1.4; }}
  .range-group {{ display: flex; align-items: center; gap: 8px; }}
  .range-group input[type="range"] {{ width: 220px; }}
  .hint {{ opacity:.8; margin-left:auto; border: none; padding:0; background:transparent; }}
</style>
</head>
<body>
<div id="container">
  <div id="toolbar">
    <label>ジャンプ:
      <select id="jumper">
        <option value="">— 場所を選択 —</option>
        {"".join(f'<option value="{{x:{p["x"]},y:{p["y"]},z:{p["z"]}}}">{esc(p["name"])}</option>' for p in locations)}
      </select>
    </label>
    <button id="resetBtn">リセット</button>
    <label title="地名ラベルの表示/非表示">
      <input type="checkbox" id="toggleLabels" checked> ラベル表示
    </label>
    <span class="hint">北=上（Z負）、東=右（X正） | Scroll: ズーム / Drag: パン / クリック: 「X Y Z」をコピー（背景はY=100）</span>
  </div>

  <div id="toolbar2">
    <div class="range-group">
      <label for="radiusRange">マーカー半径</label>
      <input type="range" id="radiusRange" min="5" max="200" step="1" value="40">
      <span id="radiusVal">40</span>
    </div>
    <div class="range-group">
      <label for="labelRange">ラベル文字サイズ</label>
      <input type="range" id="labelRange" min="20" max="300" step="1" value="80">
      <span id="labelVal">80</span>
    </div>
    <div class="range-group">
      <label for="arrowRange">方位矢印の長さ</label>
      <input type="range" id="arrowRange" min="40" max="400" step="1" value="100">
      <span id="arrowVal">100</span>
    </div>
    <div class="range-group">
      <label for="strokeRange">線の太さ</label>
      <input type="range" id="strokeRange" min="1" max="30" step="1" value="8">
      <span id="strokeVal">8</span>
    </div>
    <label class="range-group" title="拡大・縮小に合わせて見た目の大きさを自動調整">
      <input type="checkbox" id="autoScale"> ズームに追随
    </label>
  </div>

  <div id="toolbarZoom">
    <div class="range-group">
      <label for="zoomRange">ズーム</label>
      <input type="range" id="zoomRange" min="0.25" max="8.00" step="0.01" value="1.00">
      <span id="zoomVal">100%</span>
    </div>
  </div>

  <div id="mapwrap">
    <svg id="map" viewBox="{vb_x} {vb_y} {vb_w} {vb_h}" preserveAspectRatio="xMidYMid meet">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse" markerUnits="userSpaceOnUse">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="#98a2b3" />
        </marker>
      </defs>
      <g id="layer-grid">
        {"".join(grid_svg)}
        {"".join(axes_svg)}
      </g>
      <g id="layer-points">
        {"".join(points_svg)}
      </g>
      <g id="layer-labels">
        {"".join(labels_svg)}
      </g>
      <g id="north-arrow">
        <line id="north-line" x1="{vb_x + 120}" y1="{vb_y + 140}" x2="{vb_x + 120}" y2="{vb_y + 40}" stroke="#98a2b3" stroke-width="8" marker-end="url(#arrow)"></line>
        <text id="north-text" x="{vb_x + 140}" y="{vb_y + 60}" fill="#98a2b3" font-size="80">N</text>
      </g>
    </svg>
    <div class="hud" id="hud">X: —, Z: —</div>
  </div>
</div>
<script>
(() => {{
  const svg = document.getElementById('map');
  const layerLabels = document.getElementById('layer-labels');
  const layerPoints = document.getElementById('layer-points');
  const resetBtn = document.getElementById('resetBtn');
  const toggleLabels = document.getElementById('toggleLabels');
  const select = document.getElementById('jumper');
  const hud = document.getElementById('hud');

  const radiusRange = document.getElementById('radiusRange');
  const labelRange  = document.getElementById('labelRange');
  const arrowRange  = document.getElementById('arrowRange');
  const strokeRange = document.getElementById('strokeRange');
  const radiusVal = document.getElementById('radiusVal');
  const labelVal  = document.getElementById('labelVal');
  const arrowVal  = document.getElementById('arrowVal');
  const strokeVal = document.getElementById('strokeVal');
  const autoScale = document.getElementById('autoScale');

  const zoomRange = document.getElementById('zoomRange');
  const zoomVal   = document.getElementById('zoomVal');

  const DEFAULT_Y = 100;

  const initVB = svg.viewBox.baseVal;
  let vb = {{ x: initVB.x, y: initVB.y, w: initVB.width, h: initVB.height }};
  const vb0 = {{ ...vb }};

  function setVB(x, y, w, h) {{
    svg.setAttribute('viewBox', `${{x}} ${{y}} ${{w}} ${{h}}`);
    vb = {{ x, y, w, h }};
    const nl = document.getElementById('north-line');
    const nt = document.getElementById('north-text');
    const baseX = x + 120;
    const baseY = y + 140;
    nl.setAttribute('x1', baseX);
    nl.setAttribute('y1', baseY);
    nt.setAttribute('x', baseX + 20);
    applySizes();
    updateZoomUI();
  }}

  function clientToWorld(evt) {{
    const rect = svg.getBoundingClientRect();
    const px = (evt.clientX - rect.left) / rect.width;
    const py = (evt.clientY - rect.top) / rect.height;
    const wx = vb.x + px * vb.w;
    const wy = vb.y + py * vb.h;
    return [wx, wy];
  }}

  function currentMagnification() {{
    return vb0.w / vb.w;
  }}

  function setMagnification(m) {{
    const cx = vb.x + vb.w / 2;
    const cy = vb.y + vb.h / 2;
    const nw = vb0.w / m;
    const nh = vb0.h / m;
    setVB(cx - nw / 2, cy - nh / 2, nw, nh);
  }}

  function updateZoomUI() {{
    const m = currentMagnification();
    zoomRange.value = m.toFixed(3);
    zoomVal.textContent = Math.round(m * 100) + '%';
  }}

  function applySizes() {{
    const scale = autoScale.checked ? (vb.w / vb0.w) : 1;
    const r  = parseFloat(radiusRange.value) * scale;
    const fs = parseFloat(labelRange.value) * scale;
    const al = parseFloat(arrowRange.value) * scale;
    const sw = parseFloat(strokeRange.value) * scale;

    radiusVal.textContent = Math.round(parseFloat(radiusRange.value));
    labelVal.textContent  = Math.round(parseFloat(labelRange.value));
    arrowVal.textContent  = Math.round(parseFloat(arrowRange.value));
    strokeVal.textContent = Math.round(parseFloat(strokeRange.value));

    document.querySelectorAll('#layer-points .poi').forEach(c => {{
      c.setAttribute('r', r);
      c.setAttribute('stroke-width', Math.max(1, sw * 0.5));
    }});

    document.querySelectorAll('#layer-labels text').forEach(t => {{
      t.setAttribute('font-size', fs);
      t.setAttribute('stroke-width', Math.max(2, sw));
    }});

    const nl = document.getElementById('north-line');
    const nt = document.getElementById('north-text');
    const x1 = parseFloat(nl.getAttribute('x1'));
    const y1 = parseFloat(nl.getAttribute('y1'));
    nl.setAttribute('x2', x1);
    nl.setAttribute('y2', y1 - al);
    nl.setAttribute('stroke-width', sw);

    const marker = document.getElementById('arrow');
    const headSize = Math.max(8, sw * 3);
    marker.setAttribute('markerWidth', headSize);
    marker.setAttribute('markerHeight', headSize);

    nt.setAttribute('y', y1 - al + headSize * 0.6);
    nt.setAttribute('font-size', fs);
  }}

  svg.addEventListener('wheel', (e) => {{
    e.preventDefault();
    const [cx, cy] = clientToWorld(e);
    const factor = (e.deltaY > 0) ? 1.15 : 1/1.15;
    const nw = vb.w * factor;
    const nh = vb.h * factor;
    const rx = (cx - vb.x) / vb.w;
    const ry = (cy - vb.y) / vb.h;
    const nx = cx - rx * nw;
    const ny = cy - ry * nh;
    setVB(nx, ny, nw, nh);
  }}, {{ passive: false }});

  let dragging = false;
  let startWorld = null;
  svg.addEventListener('mousedown', (e) => {{
    dragging = true;
    startWorld = clientToWorld(e);
  }});
  window.addEventListener('mouseup', () => dragging = false);
  svg.addEventListener('mousemove', (e) => {{
    const [wx, wy] = clientToWorld(e);
    hud.textContent = `X: ${{wx.toFixed(1)}}, Z: ${{wy.toFixed(1)}}`;
    if (!dragging || !startWorld) return;
    const dx = startWorld[0] - wx;
    const dy = startWorld[1] - wy;
    setVB(vb.x + dx, vb.y + dy, vb.w, vb.h);
  }});

  svg.addEventListener('click', (e) => {{
    const target = e.target;
    let txt;
    if (target.classList && target.classList.contains('poi')) {{
      const x = target.getAttribute('data-x');
      const y = target.getAttribute('data-y');
      const z = target.getAttribute('data-z');
      txt = `${{x}} ${{y}} ${{z}}`;
    }} else {{
      const [wx, wy] = clientToWorld(e);
      txt = `${{Math.round(wx)}} 100 ${{Math.round(wy)}}`;
    }}
    navigator.clipboard?.writeText(txt);
    hud.textContent = txt + '（コピーしました）';
    setTimeout(() => hud.textContent = txt, 1000);
  }});

  toggleLabels.addEventListener('change', () => {{
    layerLabels.style.display = toggleLabels.checked ? 'block' : 'none';
  }});

  resetBtn.addEventListener('click', () => {{
    setVB({vb_x}, {vb_y}, {vb_w}, {vb_h});
  }});

  select.addEventListener('change', () => {{
    const val = select.value;
    if (!val) return;
    const obj = JSON.parse(val.replace(/([a-zA-Z]+):/g, '"$1":'));
    const cx = obj.x, cz = obj.z;
    const m = 3;
    const nw = {vb_w} / m;
    const nh = {vb_h} / m;
    setVB(cx - nw/2, cz - nh/2, nw, nh);
  }});

  function onZoomSlider() {{
    const m = parseFloat(zoomRange.value);
    // Keep center when applying magnification
    const cx = vb.x + vb.w / 2;
    const cy = vb.y + vb.h / 2;
    const nw = {vb_w} / m;
    const nh = {vb_h} / m;
    setVB(cx - nw/2, cy - nh/2, nw, nh);
  }}
  zoomRange.addEventListener('input', onZoomSlider);
  zoomRange.addEventListener('change', onZoomSlider);

  [radiusRange, labelRange, arrowRange, strokeRange, autoScale].forEach(el => {{
    el.addEventListener('input', applySizes);
    el.addEventListener('change', applySizes);
  }});

  applySizes();
  // Sync zoom UI initially
  (function initZoomUI() {{
    zoomRange.value = "1.00";
    zoomVal.textContent = "100%";
  }})();
}})();
</script>
</body>
</html>
"""

out_path = "/mnt/data/jserver_map_interactive.html"
with open(out_path, "w", encoding="utf-8") as f:
    f.write(html)

out_path
